input {
  tcp {
    port => 514
    type => syslog
  }
  udp {
    port => 514
    type => syslog
  }
}

filter {

  # first parse out the body from the syslog format
  # we've added tags via the Docker log drivers to identify the
  # specific container and the service identifier. See:
  # https://docs.docker.com/engine/admin/logging/log_tags/
  grok {
    match => {
      "message" => '%{SYSLOG5424PRI:syslog5424_pri}+(?:%{TIMESTAMP_ISO8601:syslog_timestamp}|-) %{WORD:serviceid}/+(?:%{HOSTNAME:containerid}|-)\[+(?:%{POSINT:pid}|-)\]: %{GREEDYDATA:msg}'
      }
  }

  syslog_pri { }
  date { match => [ "syslog_timestamp", "ISO8601"] }
  if !("_grokparsefailure" in [tags]) {
    mutate {
      remove_field => [ "@source_host", "@message" ]
    }
  }
  mutate {
    remove_field => [ "syslog_hostname", "syslog_message", "syslog_timestamp" ]
  }

  # further filter to get the application-specific log format
  grok {
    # nginx access log
    match => {
      "msg" => '\[%{HTTPDATE:http_timestamp}\] %{WORD:req_id} "%{WORD:http_method} %{URIPATHPARAM:http_request} HTTP/%{NUMBER:http_version}" %{NUMBER:http_code} %{NUMBER:http_bytes_sent} (?:%{QUOTEDSTRING:http_referer}|-) %{IP:client} (?:%{QUOTEDSTRING:http_user_agent}|-)'
    }
    # nginx error msg
    match => {
      "msg" => '(?<http_timestamp>%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME}) (?<http_timestamp>%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME})? ?%{GREEDYDATA:msg}'
    }
    # mysql log messages
    match => {
      "msg" => '%{TIMESTAMP_ISO8601:mysql_timestamp} %{NUMBER} \[%{LOGLEVEL:level}\] ?%{GREEDYDATA:msg}'
    }
    # mysql manage.py log messages
    match => {
      "msg" => '(?<mysql_timestamp>%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME}) %{LOGLEVEL:level} manage %{GREEDYDATA:msg}'
    }
    # misc containerpilot msg
    match => {
      "msg" => '%{GREEDYDATA:msg}'
    }
  } # end grok

  # fortunes application
  json {
    source => "msg"
    remove_field => [ "msg" ]
  }

  # failed to match, so parse as error
  if "_grokparsefailure" in [tags] {
    mutate {
      add_tag => "error"
    }
  } else {
      mutate {
        # all this is redundant data at this point
        remove_field => [ "message", "short_message" ]
      }
  }

}

output {
  elasticsearch { hosts => ["elasticsearch"] }
  stdout { codec => rubydebug }
}
